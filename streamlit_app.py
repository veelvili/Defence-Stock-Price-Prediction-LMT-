# -*- coding: utf-8 -*-
"""streamlit_app.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1coy-aOlZH7vjxYl6RUqM1ds3TqJqPdXg
"""

import os, io, time
import numpy as np
import pandas as pd
import streamlit as st
import matplotlib.pyplot as plt
from inference import predict_series, meta_coefficients, GEO_PATH, GEO_COLS, TICKER, LOOKBACK

st.set_page_config(page_title="LMT Hybrid Stacked Model", page_icon="ðŸ“ˆ", layout="wide")

# Sidebar â€” Upload geopolitics CSV
st.sidebar.header("Geopolitics CSV")
uploaded = st.sidebar.file_uploader("Upload geopolitical_data.csv", type=["csv"], help="Must include columns: Date + " + ", ".join(GEO_COLS))

if uploaded is not None:
    os.makedirs(os.path.dirname(GEO_PATH), exist_ok=True)
    with open(GEO_PATH, "wb") as f:
        f.write(uploaded.getvalue())
    st.sidebar.success(f"Saved to {GEO_PATH}")
    # Small preview
    try:
        df_preview = pd.read_csv(io.BytesIO(uploaded.getvalue()))
        st.sidebar.dataframe(df_preview.head(8), use_container_width=True)
    except Exception as e:
        st.sidebar.error(f"Preview failed: {e}")

# Sidebar â€” Controls
st.sidebar.header("Prediction Settings")
ticker = st.sidebar.text_input("Ticker (trained on LMT)", value=TICKER, disabled=True)
days_back = st.sidebar.slider("Days to display", min_value=60, max_value=730, value=250, step=10)
run_btn = st.sidebar.button("Run Prediction")

st.title("ðŸ“ˆ LMT Hybrid Stacked Model (LSTM + RF + XGB + SVR â†’ Linear Stack)")
st.caption(f"Lookback window: {LOOKBACK} days. Adjusted OHLC from yfinance. Geopolitics CSV path: `{GEO_PATH}`")

if run_btn:
    with st.spinner("Fetching data, merging geopolitics, and predictingâ€¦"):
        try:
            df = predict_series(days_back=days_back, ticker=ticker)
        except Exception as e:
            st.error(f"Prediction failed: {e}")
            st.stop()

    if df.empty or df.shape[0] < 5:
        st.warning("Not enough data to plot. Try increasing 'Days to display' or ensure your geopolitics CSV covers recent dates.")
        st.stop()

    latest_date = df.index[-1]
    latest = df.iloc[-1]

    # KPI row
    c1, c2, c3, c4 = st.columns(4)
    c1.metric("Latest Actual (Adj Close)", f"${latest['Actual']:.2f}")
    c2.metric("Stacked Prediction", f"${latest['STACKED']:.2f}", f"{(latest['STACKED']-latest['Actual'])/latest['Actual']*100:+.2f}%")
    c3.metric("Best Base (SVR)", f"${latest['SVR']:.2f}")
    c4.metric("Run Date", str(latest_date.date()))

    # Plot â€” Actual vs Stacked vs Bases
    st.subheader("Actual vs Predictions")
    fig, ax = plt.subplots(figsize=(11,5))
    ax.plot(df.index, df["Actual"], label="Actual", lw=2.2, color="black")
    ax.plot(df.index, df["STACKED"], label="STACKED", lw=2.0, color="gold")
    ax.plot(df.index, df["SVR"], label="SVR", lw=1.2, alpha=0.9)
    ax.plot(df.index, df["LSTM"], label="LSTM", lw=1.0, alpha=0.8)
    ax.plot(df.index, df["RF"], label="RF", lw=1.0, alpha=0.8)
    ax.plot(df.index, df["XGB"], label="XGB", lw=1.0, alpha=0.8)
    ax.grid(True, alpha=0.3)
    ax.legend(loc="upper left")
    ax.set_xlabel("Date"); ax.set_ylabel("Price (USD)")
    st.pyplot(fig, clear_figure=True)

    # Error diagnostics
    st.subheader("Error Diagnostics (last window)")
    df_err = pd.DataFrame({
        "AbsError_STACKED": (df["STACKED"] - df["Actual"]).abs(),
        "PctError_STACKED": (df["STACKED"] - df["Actual"]) / df["Actual"]
    }, index=df.index)
    colA, colB, colC = st.columns(3)
    colA.metric("MAE (STACKED)", f"${df_err['AbsError_STACKED'].mean():.2f}")
    colB.metric("|5%| Error Share", f"{(df_err['PctError_STACKED'].abs() > 0.05).mean():.2%}")
    colC.metric("Dir. Accuracy", f"{(np.sign(df['STACKED'].diff()) == np.sign(df['Actual'].diff())).mean():.2%}")

    st.dataframe(df.tail(15).round(2), use_container_width=True)

    # Meta weights
    st.subheader("Meta-Learner Coefficients")
    coeffs = meta_coefficients()
    st.json(coeffs)

else:
    st.info("Upload your geopolitics CSV (if needed) and click **Run Prediction**.")

st.caption("Note: Models must match the training pipeline (features, lookback, scaling).")